#!/bin/bash

cd "$(dirname "$0")/.." || exit 1

function show_help() {
    cat << EOF
Usage: $0 [OPTIONS] <test_corpus_directory>

This script parses Elm files in a test corpus with tree-sitter.

ARGUMENTS:
    <test_corpus_directory>    Directory path where the test corpus is located

OPTIONS:
    --clone-test-corpus        Clone the test corpus from the URL specified in script/TEST_CORPUS_REPO
    --tspath PATH              Path to tree-sitter binary (default: npx tree-sitter)
    --expect-fail FILE         File containing list of expected failures (paths relative to test_corpus_directory)
    --help                     Show this help message and exit

EXAMPLES:
    $0 /path/to/test-corpus
    $0 --expect-fail script/expected_fails.txt --clone-test-corpus /path/to/test-corpus
    $0 --tspath /usr/local/bin/tree-sitter /path/to/test-corpus
    $0 --expect-fail script/expected_fails.txt /path/to/test-corpus
EOF
}

TREE_SITTER_CMD='npx tree-sitter'
TEST_CORPUS_DIR=""
EXPECT_FAIL_FILE=""
CLONE_CORPUS=false

while [[ $# -gt 0 ]]; do
  case $1 in
    --clone-test-corpus)
      CLONE_CORPUS=true
      shift
      ;;
    --tspath)
      TREE_SITTER_CMD="$2"
      shift 2
      ;;
    --expect-fail)
      EXPECT_FAIL_FILE="$2"
      shift 2
      ;;
    --help)
      show_help
      exit 0
      ;;
    -*)
      echo "Unknown option: $1"
      show_help
      exit 1
      ;;
    *)
      if [ -z "$TEST_CORPUS_DIR" ]; then
        TEST_CORPUS_DIR="$1"
      else
        echo "Error: Too many arguments"
        show_help
        exit 1
      fi
      shift
      ;;
  esac
done

if [ -z "$TEST_CORPUS_DIR" ]; then
  echo "Error: test_corpus_directory is required"
  show_help
  exit 1
fi

if [ "$CLONE_CORPUS" = true ]; then
  SCRIPT_DIR="$(dirname "$0")"
  TEST_CORPUS_REPO_FILE="$SCRIPT_DIR/TEST_CORPUS_REPO"
  
  if [ ! -f "$TEST_CORPUS_REPO_FILE" ]; then
    echo "Error: TEST_CORPUS_REPO file not found at $TEST_CORPUS_REPO_FILE"
    exit 1
  fi
  
  CLONE_URL=$(cat "$TEST_CORPUS_REPO_FILE" | tr -d '[:space:]')
  
  if [ -z "$CLONE_URL" ]; then
    echo "Error: TEST_CORPUS_REPO file is empty"
    exit 1
  fi
  
  if [[ "$CLONE_URL" != https://* ]] && [[ "$CLONE_URL" != git@* ]]; then
    CLONE_URL="https://$CLONE_URL"
  fi
  
  if [ -d "$TEST_CORPUS_DIR/.git" ]; then
    echo "Updating test corpus..."
    git -C "$TEST_CORPUS_DIR" fetch && git -C "$TEST_CORPUS_DIR" reset --hard origin/HEAD
  else
    echo "Cloning test corpus..."
    git clone "$CLONE_URL" "$TEST_CORPUS_DIR"
  fi
fi

if [ ! -d "$TEST_CORPUS_DIR" ]; then
  echo "Error: Test corpus directory does not exist: $TEST_CORPUS_DIR"
  echo "Use --clone-test-corpus to clone it first."
  exit 1
fi

if ! command -v ${TREE_SITTER_CMD%% *} >/dev/null 2>&1 && ! ${TREE_SITTER_CMD%% *} --version >/dev/null 2>&1; then
  echo "Error: tree-sitter command not found: $TREE_SITTER_CMD"
  echo "Please install tree-sitter or specify the path with --tspath"
  exit 1
fi

echo "Parsing..."
start=$(date +%s.%N)
tree_sitter_output=$($TREE_SITTER_CMD parse "$TEST_CORPUS_DIR"/**/*.elm --quiet --stat 2>&1)
end=$(date +%s.%N)

ret_code=$?

# Separate the file results from the summary stats (stats start with Total or parenthesized time)
stats_lines=$(echo "$tree_sitter_output" | grep -E '^(Total|\([0-9]+ ms\))')
# Extract only lines that look like file paths (start with / or ./) - filters out warnings and other messages
file_results=$(echo "$tree_sitter_output" | grep -E '^(/|\./)' | grep -v "^$")

# Extract failed files (lines containing "PARSE ERROR" or similar failure indicators)
failed_files="$file_results"

# If we have an expected failures file, process against it
if [ -n "$EXPECT_FAIL_FILE" ] && [ -f "$EXPECT_FAIL_FILE" ]; then
  tmp_expected=$(mktemp)
  tmp_actual_fails=$(mktemp)
  tmp_unexpected_fails=$(mktemp)
  tmp_unexpected_successes=$(mktemp)
  
  trap 'rm -f "$tmp_expected" "$tmp_actual_fails" "$tmp_unexpected_fails" "$tmp_unexpected_successes"' EXIT
  
  grep -v '^[[:space:]]*#' "$EXPECT_FAIL_FILE" | grep -v '^[[:space:]]*$' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//' | sort -u > "$tmp_expected"

  echo "$failed_files" | while IFS= read -r line; do
    if [ -n "$line" ]; then
      # Extract the file path from the line (it's at the beginning before any status)
      file_path=$(echo "$line" | awk '{print $1}')
      # Convert absolute path to relative path (relative to TEST_CORPUS_DIR)
      rel_path="${file_path#"$TEST_CORPUS_DIR"/}"
      echo "$rel_path"
    fi
  done | sort -u > "$tmp_actual_fails"

  # Find unexpected failures (in actual but not in expected)
  comm -23 "$tmp_actual_fails" "$tmp_expected" > "$tmp_unexpected_fails"
  
  # Find expected failures that didn't fail (in expected but not in actual)
  # But only if the file actually exists
  while IFS= read -r ef; do
    if [ -f "$TEST_CORPUS_DIR/$ef" ]; then
      echo "$ef"
    fi
  done < <(comm -23 "$tmp_expected" "$tmp_actual_fails") > "$tmp_unexpected_successes"

  unexpected_fail_count=$(wc -l < "$tmp_unexpected_fails" | tr -d ' ')
  unexpected_success_count=$(wc -l < "$tmp_unexpected_successes" | tr -d ' ')

  echo -e "-----------------------------------------------------------------"
  
  if [ "$unexpected_fail_count" -gt 0 ]; then
    echo "UNEXPECTED FAILURES ($unexpected_fail_count):"
    while IFS= read -r uf; do
      echo "  $uf"
    done < "$tmp_unexpected_fails"
    echo ""
  else
    echo "No unexpected failures!"
    echo ""
  fi
  
  if [ "$unexpected_success_count" -gt 0 ]; then
    echo "UNEXPECTED SUCCESSES (expected to fail but passed) ($unexpected_success_count):"
    while IFS= read -r us; do
      echo "  $us"
    done < "$tmp_unexpected_successes"
    echo ""
  else
    echo "All expected failures failed as expected."
    echo ""
  fi
  
  total_errors=$((unexpected_fail_count + unexpected_success_count))
  
  total_parses=$(echo "$stats_lines" | grep -oE 'Total parses: [0-9]+' | grep -oE '[0-9]+')
  if [ -n "$total_parses" ] && [ "$total_parses" -gt 0 ]; then
    correct_parses=$((total_parses - total_errors))
    # Calculate percentage using awk for floating point to be compatible with mac and linux
    success_pct=$(awk "BEGIN {printf \"%.2f\", ($correct_parses / $total_parses) * 100}")
  else
    total_parses="N/A"
    correct_parses="N/A"
    success_pct="N/A"
  fi
  
  echo "Summary:"
  echo "  Total files parsed: $total_parses"
  echo "  Successful parses: $correct_parses"
  echo "  Unexpected failures: $unexpected_fail_count"
  echo "  Unexpected successes: $unexpected_success_count"
  echo "  Total errors: $total_errors"
  echo "  Success rate: $success_pct%"
  echo -e "-----------------------------------------------------------------\n"
  
  # Set exit code based on total errors (unexpected failures OR unexpected successes)
  if [ "$total_errors" -gt 0 ]; then
    ret_code=1
  else
    ret_code=0
  fi
else
  echo -e "-----------------------------------------------------------------\n$tree_sitter_output \n -----------------------------------------------------------------\n"
fi

runtime=$(awk "BEGIN {printf \"%.3f\", $end - $start}")

printf "Took: %s seconds\n" "$runtime"

exit $ret_code
